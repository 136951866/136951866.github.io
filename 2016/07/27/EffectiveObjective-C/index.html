<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="技以安身 德以立命">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    EffectiveObjective-C |
    
    Hank</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hank" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-EffectiveObjective-C" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  EffectiveObjective-C
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2016/07/27/EffectiveObjective-C/" class="article-date">
  <time datetime="2016-07-27T01:56:29.000Z" itemprop="datePublished">2016-07-27</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">技术读书笔记</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        
        
          <p>EffectiveObjective-C 读书笔记</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="了解Objective-C的起源"><a href="#了解Objective-C的起源" class="headerlink" title="了解Objective-C的起源"></a>了解Objective-C的起源</h2><h3 id="运行期组件"><a href="#运行期组件" class="headerlink" title="运行期组件"></a>运行期组件</h3><p>对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才会去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用Objective-C的面向对象特性所需的全部数据结构以及函数都在运行期组件里面</p>
<p>内存：对象分配到堆空间,指针分配到栈空间。<br>分配在队中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><p>在设置完属性后，编译器会自动写出一套存取方法，用于访问相应名称的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (NSString*)firstName;</span><br><span class="line">- (void)setFirstName:(NSString*)firstName;</span><br><span class="line">- (NSString*)lastName;</span><br><span class="line">- (void)setLastName:(NSString*)lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>访问属性，可以使用点语法。编译器会把点语法转换为对存取方法的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aPerson.firstName &#x3D; @&quot;Bob&quot;; &#x2F;&#x2F; Same as:</span><br><span class="line">[aPerson setFirstName:@&quot;Bob&quot;];</span><br><span class="line"></span><br><span class="line">NSString *lastName &#x3D; aPerson.lastName; &#x2F;&#x2F; Same as:</span><br><span class="line">NSString *lastName &#x3D; [aPerson lastName];</span><br></pre></td></tr></table></figure>
<p>如果我们不希望编译器自动生成存取方法的话，需要设置@dynamic 字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSManagedObject</span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCPerson</span><br><span class="line">@dynamic firstName, lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="属相特质"><a href="#属相特质" class="headerlink" title="属相特质"></a>属相特质</h3><p>定义属性的时候，通常会赋予它一些特性，来满足一些对类保存数据所要遵循的需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nonatomic：不使用同步锁</span><br><span class="line">atomic：加同步锁，确保其原子性</span><br><span class="line">readwrite:同时存在存取方法</span><br><span class="line">readonly:只有获取方法</span><br><span class="line">assign:纯量类型(scalar type)的简单赋值操作</span><br><span class="line">strong:拥有关系保留新值，释放旧值，再设置新值</span><br><span class="line">weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空</span><br><span class="line">unsafe_unretained ：类似assign，适用于对象类型，非拥有关系，属性所指的对象遭到摧毁时，属性不会清空。</span><br><span class="line">copy：不保留新值，而是将其拷贝</span><br></pre></td></tr></table></figure>
<h3 id="注意：遵循属性定义"><a href="#注意：遵循属性定义" class="headerlink" title="注意：遵循属性定义"></a>注意：遵循属性定义</h3><p>如果属性定义为copy，那么在非设置方法里设定属性的时候，也要遵循copy的语义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName</span><br><span class="line">&#123;</span><br><span class="line">         if ((self &#x3D; [super init])) &#123;</span><br><span class="line">            _firstName &#x3D; [firstName copy];</span><br><span class="line">            _lastName &#x3D; [lastName copy];</span><br><span class="line">        &#125;</span><br><span class="line">       return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象等同性"><a href="#对象等同性" class="headerlink" title="对象等同性"></a>对象等同性</h2><h3 id="同等性判断"><a href="#同等性判断" class="headerlink" title="同等性判断"></a>同等性判断</h3><p>==操作符比较的是指针值，也就是内存地址</p>
<p>另外，如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的isEqual:方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;先比较对象类型，然后比较每个属性</span><br><span class="line">     if (self &#x3D;&#x3D; object) return YES;</span><br><span class="line">     if (![_firstName isEqualToString:otherPerson.firstName])</span><br><span class="line">         return NO;</span><br><span class="line">     if (![_lastName isEqualToString:otherPerson.lastName])</span><br><span class="line">         return NO;</span><br><span class="line">     if (_age !&#x3D; otherPerson.age)</span><br><span class="line">         return NO;</span><br><span class="line">     return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    &#x2F;&#x2F;如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法</span><br><span class="line">     if ([self class] &#x3D;&#x3D; [object class]) &#123;    </span><br><span class="line">         return [self isEqualToPerson:(EOCPerson*)object];</span><br><span class="line">    &#125; else &#123;    </span><br><span class="line">         return [super isEqual:object];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深度等同性判定"><a href="#深度等同性判定" class="headerlink" title="深度等同性判定"></a>深度等同性判定</h3><p>比较两个数组是否相等的话可以使用深度同等性判断方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.先比较数组的个数</span><br><span class="line">2.再比较两个数组对应位置上的对象均相等。</span><br></pre></td></tr></table></figure>
<h2 id="理解objc-msgSend的作用"><a href="#理解objc-msgSend的作用" class="headerlink" title="理解objc_msgSend的作用"></a>理解objc_msgSend的作用</h2><p>在OC中，如果向某对象传递信息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数</p>
<p>然而对象收到 消息后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得OC成为一门真正的动态语言</p>
<p>在OC中，给对象发送消息的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id returnValue &#x3D; [someObject messageName:parameter];</span><br><span class="line">&#x2F;*</span><br><span class="line">第一个参数代表接收者，第二个参数代表选择子，后续参数就是消息中的那些参数，数量是可变的，所以这个函数就是参数个数可变的函数</span><br><span class="line">*&#x2F;</span><br><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br><span class="line"></span><br><span class="line">因此，上述以OC形式展现出来的函数就会转化成如下函数:</span><br><span class="line"></span><br><span class="line">d returnValue &#x3D; objc_msgSend(someObject,@selector(messageName:),parameter);</span><br><span class="line">&#x2F;*</span><br><span class="line">这个函数会在接收者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就去实现代码，如果找不到就沿着继承体系继续向上查找。如果找到了就执行，如果最终还是找不到，就执行消息转发操作</span><br><span class="line"></span><br><span class="line">注意：如果匹配成功的话，这种匹配的结果会缓存在“快速映射表”里面。每个类都有这样一块缓存。所以如果将来再次向该类发送形同的消息，执行速度就会更快了。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h2><p>如果对象所属类和其所有的父类都无法解读收到的消息，就会启动消息转发机制<br><img src="http://upload-images.jianshu.io/upload_images/859001-6619cbf33830ce3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>类方法+(BOOL)resolveInstanceMethod:(SEL)selector:查看这个类是否能新增一个实例方法用以处理此选择子</p>
<p>实例方法- (id)forwardTargetForSelector:(SEL)selector;:询问是否能找到未知消息的备援接受者，如果能找到备援对象，就将其返回，如果不能，就返回nil</p>
<p>实例方法- (void)forwardInvocation:(NSInvocation*)invocation:创建NSInvocation对象，将尚未处理的那条消息 有关的全部细节都封于其中，在触发NSInvocation对象时，“消息派发系统（message-dispatch system）”就会将消息派给目标对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">code: 动态添加set get 方法</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCAutoDictionary : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *string;</span><br><span class="line">@property (nonatomic, strong) NSNumber *number;</span><br><span class="line">@property (nonatomic, strong) NSDate *date;</span><br><span class="line">@property (nonatomic, strong) id opaqueObject;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;EOCAutoDictionary.h&quot;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCAutoDictionary ()</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *backingStore;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCAutoDictionary</span><br><span class="line">@dynamic string, number, date, opaqueObject;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line"> if ((self &#x3D; [super init])) &#123;</span><br><span class="line">    _backingStore &#x3D; [NSMutableDictionary new];</span><br><span class="line">&#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector &#123;</span><br><span class="line">     NSString *selectorString &#x3D; NSStringFromSelector(selector);</span><br><span class="line">     if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</span><br><span class="line">         class_addMethod(self,selector,(IMP)autoDictionarySetter, &quot;v@:@&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         class_addMethod(self,selector,(IMP)autoDictionaryGetter, &quot;@@:&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void autoDictionaryGetter(id self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Get the backing store from the object</span><br><span class="line">     EOCAutoDictionary *typedSelf &#x3D; (EOCAutoDictionary*)self;</span><br><span class="line">     NSMutableDictionary *backingStore &#x3D; typedSelf.backingStore;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; The key is simply the selector name</span><br><span class="line">     NSString *key &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Return the value</span><br><span class="line">     return [backingStore objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value) &#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Get the backing store from the object</span><br><span class="line">     EOCAutoDictionary *typedSelf &#x3D; (EOCAutoDictionary*)self;</span><br><span class="line">     NSMutableDictionary *backingStore &#x3D; typedSelf.backingStore;</span><br><span class="line"></span><br><span class="line">     &#x2F;** The selector will be for example, &quot;setOpaqueObject:&quot;.</span><br><span class="line">     * We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first</span><br><span class="line">     * letter of the remainder.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     NSString *selectorString &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line">     NSMutableString *key &#x3D; [selectorString mutableCopy];</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Remove the &#39;:&#39; at the end</span><br><span class="line">    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Remove the &#39;set&#39; prefix</span><br><span class="line">    [key deleteCharactersInRange:NSMakeRange(0, 3)];</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Lowercase the first character</span><br><span class="line">     NSString *lowercaseFirstChar &#x3D; [[key substringToIndex:1] lowercaseString];</span><br><span class="line">    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];</span><br><span class="line"></span><br><span class="line">     if (value) &#123;</span><br><span class="line">       [backingStore setObject:value forKey:key];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [backingStore removeObjectForKey:key];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="理解“类对象”的用意"><a href="#理解“类对象”的用意" class="headerlink" title="理解“类对象”的用意"></a>理解“类对象”的用意</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">    struct objc_class &#123;</span><br><span class="line">         Class isa;&#x2F;&#x2F;isa指针指向了对象所属的类：元类（metaclass）</span><br><span class="line">         Class super_class;&#x2F;&#x2F;super_class定义了本类的超类</span><br><span class="line">         const char *name;</span><br><span class="line">         long version;</span><br><span class="line">         long info;</span><br><span class="line">         long instance_size;</span><br><span class="line">         struct objc_ivar_list *ivars;</span><br><span class="line">         struct objc_method_list **methodLists;</span><br><span class="line">         struct objc_cache *cache;</span><br><span class="line">         struct objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们使用isMemberOfClass:能够判断出对象是否为某个特定类的实例；<br>而isKindOfClass:方法能够判断出对象是否为某类或其派生类的实例。<br>这两种方法都是利用了isa指针获取对象所属的类，然后通过super_class类在继承体系中查询</p>
<h2 id="理解Objective-C错误类型"><a href="#理解Objective-C错误类型" class="headerlink" title="理解Objective-C错误类型"></a>理解Objective-C错误类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface NSError : NSObject &lt;NSCopying, NSSecureCoding&gt; &#123;</span><br><span class="line">    @private</span><br><span class="line">    void *_reserved;</span><br><span class="line">    NSInteger _code;错误码，类型是整数</span><br><span class="line">    NSString *_domain;&#x2F;&#x2F;错误范围，类型是字符串</span><br><span class="line">    NSDictionary *_userInfo;&#x2F;&#x2F;用户信息，类型是字典</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; EOCErrors.h</span><br><span class="line">extern NSString *const EOCErrorDomain;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义错误码</span><br><span class="line">typedef NS_ENUM(NSUInteger, EOCError) &#123;</span><br><span class="line"></span><br><span class="line">    EOCErrorUnknown &#x3D; –1,</span><br><span class="line">    EOCErrorInternalInconsistency &#x3D; 100,</span><br><span class="line">    EOCErrorGeneralFault &#x3D; 105,</span><br><span class="line">    EOCErrorBadInput &#x3D; 500,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; EOCErrors.m</span><br><span class="line">NSString *const EOCErrorDomain &#x3D; @&quot;EOCErrorDomain&quot;; &#x2F;&#x2F;定义错误范围</span><br></pre></td></tr></table></figure>
<h2 id="理解NSCopying协议"><a href="#理解NSCopying协议" class="headerlink" title="理解NSCopying协议"></a>理解NSCopying协议</h2><p>如果我们想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone*)zone &#123;</span><br><span class="line"></span><br><span class="line">     EOCPerson *copy &#x3D; [[[self class] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];</span><br><span class="line">    copy-&gt;_friends &#x3D; [_friends mutableCopy];</span><br><span class="line">     return copy;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;之所以是copy-&gt;_friends，而不是copy.friends是因为friends并不是属性，而是一个内部使用的实例变量。</span><br></pre></td></tr></table></figure>
<h3 id="复制可变的版本"><a href="#复制可变的版本" class="headerlink" title="复制可变的版本"></a>复制可变的版本</h3><p>注意：拷贝可变型和不可变型发送的是copy和mutableCopy消息，而我们实现的却是- (id)copyWithZone:(NSZone*)zone和- (id)mutableCopyWithZone:(NSZone*)zone 方法。</p>
<p>而且，如果我们想获得某对象的不可变型，统一调用copy方法；获得某对象的可变型，统一调用mutableCopy方法。<br>例如数组的拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[NSMutableArray copy] &#x3D;&gt; NSArray</span><br><span class="line">-[NSArray mutableCopy] &#x3D;&gt; NSMutableArray</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>Foundation框架中的集合类默认都执行浅拷贝：只拷贝容器对象本身，而不复制其中的数据。而深拷贝的意思是连同对象本身和它的底层数据都要拷贝。</p>
<h2 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h2><h3 id="计数器的操作"><a href="#计数器的操作" class="headerlink" title="计数器的操作"></a>计数器的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retain：递增保留计数。</span><br><span class="line">release：递减保留计数</span><br><span class="line">autorelease ：待稍后清理“自动释放池时”，再递减保留计数。</span><br></pre></td></tr></table></figure>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>将对象放入自动释放池之后，不会马上使其引用计数-1，而是在当前线程的下一次事件循环时递减</p>
<h3 id="保留环"><a href="#保留环" class="headerlink" title="保留环"></a>保留环</h3><p>对象之间相互用强引用指向对方，会使得全部都无法得以释放。解决方案是讲其中一端的引用改为弱引用（weak reference），在引用的同时不递增引用计数。</p>
<h2 id="以ARC简化引用计数"><a href="#以ARC简化引用计数" class="headerlink" title="以ARC简化引用计数"></a>以ARC简化引用计数</h2><p>ARC只负责管理OC对象的内存，CoreFoundation对象不归ARC管理</p>
<h2 id="理解“块”这一概念"><a href="#理解“块”这一概念" class="headerlink" title="理解“块”这一概念"></a>理解“块”这一概念</h2><p>NSGlobalBlock：类似函数，位于text段；<br>NSStackBlock：位于栈内存，函数返回后Block将无效；<br>NSMallocBlock：位于堆内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">BlkSum blk1 &#x3D; ^ long (int a, int b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;blk1 &#x3D; %@&quot;, blk1);&#x2F;&#x2F; 打印结果：blk1 &#x3D; &lt;__NSGlobalBlock__: 0x47d0&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line">int base &#x3D; 100;</span><br><span class="line">BlkSum blk2 &#x3D; ^ long (int a, int b) &#123;</span><br><span class="line">  &#x2F;&#x2F;局部变量base当前值被copy到栈上，作为常量供Block使用 耨需要改变则需要 ————block int base </span><br><span class="line">  return base + a + b;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;blk2 &#x3D; %@&quot;, blk2); &#x2F;&#x2F; 打印结果：blk2 &#x3D; &lt;__NSStackBlock__: 0xbfffddf8&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例3:</span><br><span class="line"></span><br><span class="line">BlkSum blk3 &#x3D; [[blk2 copy] autorelease];</span><br><span class="line">NSLog(@&quot;blk3 &#x3D; %@&quot;, blk3); &#x2F;&#x2F; 打印结果：blk3 &#x3D; &lt;__NSMallocBlock__: 0x902fda0&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">static变量、全局变量。如果把上个例子的base改成全局的、或static。Block就可以对他进行读写了。因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量</span><br><span class="line">*&#x2F;</span><br><span class="line">static int base &#x3D; 100;</span><br><span class="line">BlkSum sum &#x3D; ^ long (int a, int b) &#123;</span><br><span class="line">  base++;</span><br><span class="line">  return base + a + b;</span><br><span class="line">&#125;;</span><br><span class="line">base &#x3D; 0;</span><br><span class="line">printf(&quot;%d\n&quot;, base);&#x2F;&#x2F;0</span><br><span class="line">printf(&quot;%ld\n&quot;,sum(1,2)); &#x2F;&#x2F; 这里输出是4</span><br><span class="line">printf(&quot;%d\n&quot;, base);&#x2F;&#x2F;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>在ARC下不用__block ，而是用 __weak 为了避免出现循环引用</p>
<p>在MRC：用__block ，__block修饰的变量在Block copy时是不会retain的，所以，也可以做到破解循环引用。</p>
<h1 id="规范篇"><a href="#规范篇" class="headerlink" title="规范篇"></a>规范篇</h1><h2 id="在类的头文件中尽量少引用其他头文件"><a href="#在类的头文件中尽量少引用其他头文件" class="headerlink" title="在类的头文件中尽量少引用其他头文件"></a>在类的头文件中尽量少引用其他头文件</h2><p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; EOCPerson.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class EOCEmployer;</span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy) NSString *lastName;</span><br><span class="line">@property (nonatomic, strong) EOCEmployer *employer;&#x2F;&#x2F;将EOCEmployer作为属性</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; EOCPerson.m</span><br><span class="line">#import &quot;EOCEmployer.h&quot;</span><br></pre></td></tr></table></figure>
<p>优点：<br>不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。</p>
<p>可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</p>
<h2 id="多用字面量语法，少用与之等价的方法"><a href="#多用字面量语法，少用与之等价的方法" class="headerlink" title="多用字面量语法，少用与之等价的方法"></a>多用字面量语法，少用与之等价的方法</h2><h3 id="声明时的字面量语法"><a href="#声明时的字面量语法" class="headerlink" title="声明时的字面量语法"></a>声明时的字面量语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *intNumber &#x3D; @1;</span><br><span class="line">NSNumber *floatNumber &#x3D; @2.5f;</span><br><span class="line">Dictionary *dict &#x3D; @&#123;@&quot;animal&quot;:@&quot;tiger&quot;,@&quot;phone&quot;:@&quot;iPhone 6&quot;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="集合类取下标的字面量语法"><a href="#集合类取下标的字面量语法" class="headerlink" title="集合类取下标的字面量语法"></a>集合类取下标的字面量语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *cat &#x3D; animals[0];</span><br><span class="line">NSString *iphone &#x3D; dict[@&quot;phone&quot;];</span><br></pre></td></tr></table></figure>

<h2 id="多用类型常量，少用-define预处理命令"><a href="#多用类型常量，少用-define预处理命令" class="headerlink" title="多用类型常量，少用#define预处理命令"></a>多用类型常量，少用#define预处理命令</h2><p>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</p>
<p>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</p>
<p>类型常量:static const NSTimeIntervalDuration = 0.3;<br>对外公开某个常量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;header file</span><br><span class="line">extern NSString *const NotificationString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;implementation file</span><br><span class="line">NSString *const  NotificationString &#x3D; @&quot;Finish Download&quot;;</span><br></pre></td></tr></table></figure>
<p>注意：公开的常量：常量的名字最好用与之相关的类名做前缀。<br>非公开的常量：局限于某个编译单元（tanslation unit，实现文件 implementation file）内，在签名加上字母k。</p>
<h2 id="用枚举表示状态，选项，状态码"><a href="#用枚举表示状态，选项，状态码" class="headerlink" title="用枚举表示状态，选项，状态码"></a>用枚举表示状态，选项，状态码</h2><p>我们经常需要给类定义几个状态，这些状态码可以用枚举来管理。下面是关于网络连接状态的状态码枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</span><br><span class="line">  EOCConnectionStateDisconnected,</span><br><span class="line">  EOCConnectionStateConnecting,</span><br><span class="line">  EOCConnectionStateConnected,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="用前缀-避免命名空间冲突"><a href="#用前缀-避免命名空间冲突" class="headerlink" title="用前缀 避免命名空间冲突"></a>用前缀 避免命名空间冲突</h2><p>Apple宣称其保留使用所有”两字母前缀”的权利，所以我们选用的前缀应该是三个字母的。<br>而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。</p>
<h2 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h2><p>在头文件中，设置对象属性为readonly，在实现文件中设置为readwrite。这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line">@property (nonatomic, strong, readonly) NSSet *friends <span class="comment">//向外公开的不可变集合</span></span><br><span class="line"></span><br><span class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</span><br><span class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person;</span><br><span class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@<span class="function">interface <span class="title">EOCPerson</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">@property (nonatomic, copy, readwrite) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readwrite) NSString *lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCPerson &#123;</span><br><span class="line">     NSMutableSet *_internalFriends;  <span class="comment">//实现文件里的可变集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSSet*)friends &#123;</span><br><span class="line">     <span class="keyword">return</span> [_internalFriends copy]; <span class="comment">//get方法返回的永远是可变set的不可变型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person &#123;</span><br><span class="line">    [_internalFriends addObject:person]; <span class="comment">//在外部增加集合元素的操作</span></span><br><span class="line">    <span class="comment">//do something when add element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person &#123;</span><br><span class="line">    [_internalFriends removeObject:person]; <span class="comment">//在外部移除元素的操作</span></span><br><span class="line">    <span class="comment">//do something when remove element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((self = [super init])) &#123;</span><br><span class="line">        _firstName = firstName;</span><br><span class="line">        _lastName = lastName;</span><br><span class="line">        _internalFriends = [NSMutableSet <span class="keyword">new</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用清晰而协调的命名方式"><a href="#使用清晰而协调的命名方式" class="headerlink" title="使用清晰而协调的命名方式"></a>使用清晰而协调的命名方式</h2><h3 id="每个冒号左边的方法部分最好与右边的参数名一致。"><a href="#每个冒号左边的方法部分最好与右边的参数名一致。" class="headerlink" title="每个冒号左边的方法部分最好与右边的参数名一致。"></a>每个冒号左边的方法部分最好与右边的参数名一致。</h3><h3 id="获取”是否“的布尔值，应该增加“is”前缀"><a href="#获取”是否“的布尔值，应该增加“is”前缀" class="headerlink" title="获取”是否“的布尔值，应该增加“is”前缀"></a>获取”是否“的布尔值，应该增加“is”前缀</h3><h3 id="获取“是否有”的布尔值，应该增加“has”前缀"><a href="#获取“是否有”的布尔值，应该增加“has”前缀" class="headerlink" title="获取“是否有”的布尔值，应该增加“has”前缀"></a>获取“是否有”的布尔值，应该增加“has”前缀</h3><h2 id="为私有方法名加前缀"><a href="#为私有方法名加前缀" class="headerlink" title="为私有方法名加前缀"></a>为私有方法名加前缀</h2><p>建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@interface EOCObject : NSObject</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)publicMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation EOCObject</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)publicMethod &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)p_privateMethod &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>注意：<br>不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。</p>
<h2 id="将类的实现代码分散到便于管理的数个分类中"><a href="#将类的实现代码分散到便于管理的数个分类中" class="headerlink" title="将类的实现代码分散到便于管理的数个分类中"></a>将类的实现代码分散到便于管理的数个分类中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">无分类的类：</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *friends;</span><br><span class="line"></span><br><span class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</span><br><span class="line"></span><br><span class="line">&#x2F;* Friendship methods *&#x2F;</span><br><span class="line">- (void)addFriend:(EOCPerson*)person;</span><br><span class="line">- (void)removeFriend:(EOCPerson*)person;</span><br><span class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* Work methods *&#x2F;</span><br><span class="line">- (void)performDaysWork;</span><br><span class="line">- (void)takeVacationFromWork;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* Play methods *&#x2F;</span><br><span class="line">- (void)goToTheCinema;</span><br><span class="line">- (void)goToSportsGame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">分类之后：</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *firstName;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *lastName;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *friends;</span><br><span class="line"></span><br><span class="line">- (id)initWithFirstName:(NSString*)firstName</span><br><span class="line"></span><br><span class="line">andLastName:(NSString*)lastName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCPerson (Friendship)</span><br><span class="line"></span><br><span class="line">- (void)addFriend:(EOCPerson*)person;</span><br><span class="line">- (void)removeFriend:(EOCPerson*)person;</span><br><span class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCPerson (Work)</span><br><span class="line"></span><br><span class="line">- (void)performDaysWork;</span><br><span class="line">- (void)takeVacationFromWork;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCPerson (Play)</span><br><span class="line"></span><br><span class="line">- (void)goToTheCinema;</span><br><span class="line">- (void)goToSportsGame;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="总是为第三方类的分类名称加前缀"><a href="#总是为第三方类的分类名称加前缀" class="headerlink" title="总是为第三方类的分类名称加前缀"></a>总是为第三方类的分类名称加前缀</h2><h2 id="勿在分类中声明属性"><a href="#勿在分类中声明属性" class="headerlink" title="勿在分类中声明属性"></a>勿在分类中声明属性</h2><p>分类机制，目标在于扩展类的功能，而不是封装数据。</p>
<h2 id="在dealloc方法中只释放引用并解除监听"><a href="#在dealloc方法中只释放引用并解除监听" class="headerlink" title="在dealloc方法中只释放引用并解除监听"></a>在dealloc方法中只释放引用并解除监听</h2><p>永远不要自己调用dealloc方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在dealloc方法中做一些操作。那么我们可以在dealloc方法里做什么呢？</p>
<p>释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。</p>
<p>而且对象拥有的其他非OC对象也要释放（CoreFoundation对象就必须手动释放）</p>
<p>释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。</p>
<p>尤其注意：在dealloc方法中不应该调用其他的方法，因为如果这些方法是异步的，并且回调中还要使用当前对象，那么很有可能当前对象已经被释放了，会导致崩溃。</p>
<p>并且在dealloc方法中也不能调用属性的存取方法，因为很有可能在这些方法里还有其他操作。而且这个属性还有可能处于键值观察状态，该属性的观察者可能会在属性改变时保留或者使用这个即将回收的对象。</p>
<h2 id="多用块枚举，少用for循环"><a href="#多用块枚举，少用for循环" class="headerlink" title="多用块枚举，少用for循环"></a>多用块枚举，少用for循环</h2><p>当遍历集合元素时，建议使用块枚举，因为相对于传统的for循环，它更加高效，而且简洁,还能获取到用传统的for循环无法提供的值：</p>
<h2 id="构建缓存时选用NSCache-而非NSDictionary"><a href="#构建缓存时选用NSCache-而非NSDictionary" class="headerlink" title="构建缓存时选用NSCache 而非NSDictionary"></a>构建缓存时选用NSCache 而非NSDictionary</h2><p>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</p>
<p>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</p>
<p>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</p>
<h2 id="精简initialize-与-load的实现代码"><a href="#精简initialize-与-load的实现代码" class="headerlink" title="精简initialize 与 load的实现代码"></a>精简initialize 与 load的实现代码</h2><h3 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h3><p>每个类和分类在加入运行期系统时，都会调用load方法，而且仅仅调用一次，可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险</p>
<h3 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h3><p>这个方法与load方法类似，区别是这个方法会在程序首次调用这个类的时候调用（惰性调用），而且只调用一次（绝对不能主动使用代码调用）</p>
<p>值得注意的一点是，如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码：这个情况往往很容易让人忽视</p>
<h3 id="别忘了NSTimer会保留其目标对象"><a href="#别忘了NSTimer会保留其目标对象" class="headerlink" title="别忘了NSTimer会保留其目标对象"></a>别忘了NSTimer会保留其目标对象</h3><p>在使用NSTimer的时候，NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那么就会生成保留环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EOCClass : NSObject</span><br><span class="line">- (void)startPolling;</span><br><span class="line">- (void)stopPolling;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation EOCClass &#123;</span><br><span class="line">     NSTimer *_pollTimer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">     return [super init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_pollTimer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)stopPolling &#123;</span><br><span class="line"></span><br><span class="line">    [_pollTimer invalidate];</span><br><span class="line">    _pollTimer &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)startPolling &#123;</span><br><span class="line">   _pollTimer &#x3D; [NSTimer scheduledTimerWithTimeInterval:5.0</span><br><span class="line">                                                 target:self</span><br><span class="line">                                               selector:@selector(p_doPoll)</span><br><span class="line">                                               userInfo:nil</span><br><span class="line">                                                repeats:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)p_doPoll &#123;</span><br><span class="line">    &#x2F;&#x2F; Poll the resource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在这里，在EOCClass和_pollTimer之间形成了保留环，如果不主动调用stopPolling方法就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。</p>
<p>通过给NSTimer增加一个分类就可以解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSTimer (EOCBlocksSupport)</span><br><span class="line"></span><br><span class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                         block:(void(^)())block</span><br><span class="line">                                         repeats:(BOOL)repeats;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSTimer (EOCBlocksSupport)</span><br><span class="line"></span><br><span class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                         block:(void(^)())block</span><br><span class="line">                                        repeats:(BOOL)repeats</span><br><span class="line">&#123;</span><br><span class="line">             return [self scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                  target:self</span><br><span class="line">                                                selector:@selector(eoc_blockInvoke:)</span><br><span class="line">                                                userInfo:[block copy]</span><br><span class="line">                                                 repeats:repeats];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (void)eoc_blockInvoke:(NSTimer*)timer &#123;</span><br><span class="line">     void (^block)() &#x3D; timer.userInfo;</span><br><span class="line">         if (block) &#123;</span><br><span class="line">             block();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)startPolling &#123;</span><br><span class="line"></span><br><span class="line">         __weak EOCClass *weakSelf &#x3D; self;    </span><br><span class="line">         _pollTimer &#x3D; [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^&#123;</span><br><span class="line"></span><br><span class="line">               EOCClass *strongSelf &#x3D; weakSelf;</span><br><span class="line">               [strongSelf p_doPoll];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">                                                          repeats:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h1><h2 id="以“类族模式“隐藏实现细节"><a href="#以“类族模式“隐藏实现细节" class="headerlink" title="以“类族模式“隐藏实现细节"></a>以“类族模式“隐藏实现细节</h2><p>为什么要这么做呢?</p>
<p>笔者认为这么做的原因是为了“弱化”子类的具体类型，让开发者无需关心创建出来的子类具体属于哪个类。（这里觉得还有点什么，但是还没有想到，欢迎补充！）</p>
<p>我们可以看一个具体的例子：<br>对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">抽象基类:</span><br><span class="line">typedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123;</span><br><span class="line">    EOCEmployeeTypeDeveloper,</span><br><span class="line">    EOCEmployeeTypeDesigner,</span><br><span class="line">    EOCEmployeeTypeFinance,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface EOCEmployee : NSObject</span><br><span class="line"></span><br><span class="line">@property (copy) NSString *name;</span><br><span class="line">@property NSUInteger salary;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Helper for creating Employee objects</span><br><span class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Make Employees do their respective day&#39;s work</span><br><span class="line">- (void)doADaysWork;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCEmployee</span><br><span class="line"></span><br><span class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;</span><br><span class="line">     switch (type) &#123;</span><br><span class="line">         case EOCEmployeeTypeDeveloper:</span><br><span class="line">            return [EOCEmployeeDeveloper new];</span><br><span class="line">         break; </span><br><span class="line"></span><br><span class="line">        case EOCEmployeeTypeDesigner:</span><br><span class="line">             return [EOCEmployeeDesigner new];</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">        case EOCEmployeeTypeFinance:</span><br><span class="line">             return [EOCEmployeeFinance new];</span><br><span class="line">         break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doADaysWork &#123;</span><br><span class="line"> &#x2F;&#x2F; 需要子类来实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">实体子类（concrete subclass）:</span><br><span class="line"></span><br><span class="line">@interface EOCEmployeeDeveloper : EOCEmployee</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCEmployeeDeveloper</span><br><span class="line"></span><br><span class="line">- (void)doADaysWork &#123;</span><br><span class="line">    [self writeCode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">这里，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义。</span><br><span class="line">*&#x2F;</span><br><span class="line">void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据给定的键从某对象中获取相应的关联对象值：</span><br><span class="line">id objc_getAssociatedObject(id object, void *key)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除指定对象的关联对象：</span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code:</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static void *EOCMyAlertViewKey &#x3D; &quot;EOCMyAlertViewKey&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)askUserAQuestion &#123;</span><br><span class="line"></span><br><span class="line">         UIAlertView *alert &#x3D; [[UIAlertView alloc] initWithTitle:@&quot;Question&quot;</span><br><span class="line">                                                         message:@&quot;What do you want to do?&quot;</span><br><span class="line">                                                        delegate:self</span><br><span class="line">                                               cancelButtonTitle:@&quot;Cancel&quot;</span><br><span class="line">                                               otherButtonTitles:@&quot;Continue&quot;, nil];</span><br><span class="line"></span><br><span class="line">         void (^block)(NSInteger) &#x3D; ^(NSInteger buttonIndex)&#123;</span><br><span class="line"></span><br><span class="line">                     if (buttonIndex &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            [self doCancel];</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                            [self doContinue];</span><br><span class="line">                    &#125;</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;将alert和block关联在了一起</span><br><span class="line">         objc_setAssociatedObject(alert,EOCMyAlertViewKey,block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">         [alert show];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; UIAlertViewDelegate protocol method</span><br><span class="line">- (void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex</span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F;alert取出关联的block</span><br><span class="line">      void (^block)(NSInteger) &#x3D; objc_getAssociatedObject(alertView, EOCMyAlertViewKey)</span><br><span class="line">     &#x2F;&#x2F;给block传入index值</span><br><span class="line">      block(buttonIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用“方法调配技术”调试“黑盒方法”"><a href="#用“方法调配技术”调试“黑盒方法”" class="headerlink" title="用“方法调配技术”调试“黑盒方法”"></a>用“方法调配技术”调试“黑盒方法”</h2><p>那么如何在运行期改变选择子对应的方法呢？</p>
<p>答：通过操纵类的方法列表的IMP指针</p>
<p>什么是类方法表？什么是IMP指针呢？</p>
<p>类的方法列表会把选择子的名称映射到相关的方法实现上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这些指针叫做IMP。例如NSString类的选择子列表：</p>
<p>有了这张表，OC的运行期系统提供的几个方法就能操纵它。开发者可以向其中增加选择子，也可以改变某选择子对应的方法实现，也可以交换两个选择子所映射到的指针以达到交换方法实现的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">举个 ：交换lowercaseString和uppercaseString方法的实现：</span><br><span class="line"></span><br><span class="line">Method originalMethod &#x3D; class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method swappedMethod &#x3D; class_getInstanceMethod([NSString class],@selector(uppercaseString));</span><br><span class="line"></span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure>

<h2 id="提供”全能初始化方法”"><a href="#提供”全能初始化方法”" class="headerlink" title="提供”全能初始化方法”"></a>提供”全能初始化方法”</h2><p>有时，由于要实现各种设计需求，一个类可以有多个创建实例的初始化方法。我们应该选定其中一个作为全能初始化方法，令其他初始化方法都来调用它。</p>
<p>注意：</p>
<ul>
<li>只有在这个全能初始化方法里面才能存储内部数据。这样一来，当底层数据存储机制改变时，只需修改此方法的代码就好，无需改动其他初始化方法。</li>
<li>全能初始化方法是所有初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己</li>
<li>在我们拥有了一个全能初始化方法后，最好还是要覆写init方法来设置默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全能初始化方法</span><br><span class="line">- (id)initWithWidth:(float)width andHeight:(float)height</span><br><span class="line">&#123;</span><br><span class="line">     if ((self &#x3D; [super init])) &#123;</span><br><span class="line">        _width &#x3D; width;</span><br><span class="line">        _height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;init方法也调用了全能初始化方法</span><br><span class="line">- (id)init &#123;</span><br><span class="line">     return [self initWithWidth:5.0f andHeight:10.0f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为子类的全能初始化方法（initWithDimension:）和其父类的初始化方法并不同，所以我们需要在子类里覆写initWithWidth: andHeight:方法。</p>
<h2 id="实现description方法"><a href="#实现description方法" class="headerlink" title="实现description方法"></a>实现description方法</h2><p>如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSString*)description &#123;</span><br><span class="line">     return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;,[self class],self,</span><br><span class="line"></span><br><span class="line">    @&#123;    @&quot;title&quot;:_title,</span><br><span class="line">       @&quot;latitude&quot;:@(_latitude),</span><br><span class="line">      @&quot;longitude&quot;:@(_longitude)&#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过协议提供匿名对象"><a href="#通过协议提供匿名对象" class="headerlink" title="通过协议提供匿名对象"></a>通过协议提供匿名对象</h2><p>匿名对象（Annonymous object），可以理解为“没有名字的对象”。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。</p>
<p>它的表示方法为：id<protocol>。<br>通过协议提供匿名对象的主要使用场景有两个：</p>
<ul>
<li>作为属性</li>
<li>作为方法参数</li>
</ul>
<h3 id="匿名对象作为属性"><a href="#匿名对象作为属性" class="headerlink" title="匿名对象作为属性"></a>匿名对象作为属性</h3><p>@property (nonatomic, weak) id <EOCDelegate> delegate;</p>
<p>在这里使用匿名对象的原因有两个：</p>
<p>将来可能会有很多不同类的实例对象作为该类的代理。</p>
<p>我们不想指明具体要使用哪个类来作为这个类的代理。</p>
<h3 id="匿名对象作为方法参数"><a href="#匿名对象作为方法参数" class="headerlink" title="匿名对象作为方法参数"></a>匿名对象作为方法参数</h3><p>有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key;</span><br></pre></td></tr></table></figure>

<h2 id="编写“异常安全代码”时留意内存管理问题"><a href="#编写“异常安全代码”时留意内存管理问题" class="headerlink" title="编写“异常安全代码”时留意内存管理问题"></a>编写“异常安全代码”时留意内存管理问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">    NSMutableArray *object &#x3D; [[NSMutableArray array] copy];</span><br><span class="line">    [object addObject:@&quot;&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@catch (...) &#123;</span><br><span class="line">    NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="以弱引用避免保留环"><a href="#以弱引用避免保留环" class="headerlink" title="以弱引用避免保留环"></a>以弱引用避免保留环</h2><p>解决方案是使用弱引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;EOCClassB.m</span><br><span class="line">&#x2F;&#x2F;第一种弱引用：unsafe_unretained</span><br><span class="line">@property (nonatomic, unsafe_unretained) EOCClassA *other;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种弱引用：weak</span><br><span class="line">@property (nonatomic, weak) EOCClassA *other;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两种弱引用有什么区别呢？</p>
<p>unsafe_unretained:当指向EOCClassA实例的引用移除后，unsafe_unretained属性仍然指向那个已经回收的实例，</p>
<p>而weak指向nil：</p>
<h2 id="以“自动释放池快”降低内存峰值-MRC"><a href="#以“自动释放池快”降低内存峰值-MRC" class="headerlink" title="以“自动释放池快”降低内存峰值 (MRC)"></a>以“自动释放池快”降低内存峰值 (MRC)</h2><h2 id="用“僵尸对象”调试内存管理问题"><a href="#用“僵尸对象”调试内存管理问题" class="headerlink" title="用“僵尸对象”调试内存管理问题"></a>用“僵尸对象”调试内存管理问题</h2><p>某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。<br>如果程序没有崩溃，可能是因为：</p>
<ul>
<li>该内存的部分原数据没有被覆写。</li>
<li>该内存恰好被另一个对象占据，而这个对象可以应答这个方法。</li>
</ul>
<p>Cocoa提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改isa指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。</p>
<h2 id="为常用的块类型创建typedef"><a href="#为常用的块类型创建typedef" class="headerlink" title="为常用的块类型创建typedef"></a>为常用的块类型创建typedef</h2><p>如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int(^EOCSomeBlock)(BOOL flag, int value);</span><br></pre></td></tr></table></figure>

<h2 id="用handler块降低代码分散程度"><a href="#用handler块降低代码分散程度" class="headerlink" title="用handler块降低代码分散程度"></a>用handler块降低代码分散程度</h2><p>delegate -&gt; block</p>
<h2 id="用块引用其所属对象时不要出现保留环"><a href="#用块引用其所属对象时不要出现保留环" class="headerlink" title="用块引用其所属对象时不要出现保留环"></a>用块引用其所属对象时不要出现保留环</h2><p>如果块捕获的对象直接或间接地保留了块本身，那么就需要小心保留环问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation EOCClass &#123;</span><br><span class="line"></span><br><span class="line">     EOCNetworkFetcher *_networkFetcher;</span><br><span class="line">     NSData *_fetchedData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)downloadData &#123;</span><br><span class="line"></span><br><span class="line">     NSURL *url &#x3D; [[NSURL alloc] initWithString:@&quot;http:&#x2F;&#x2F;www.example.com&#x2F;something.dat&quot;];</span><br><span class="line">    _networkFetcher &#x3D;[[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class="line"></span><br><span class="line">    [_networkFetcher startWithCompletionHandler:^(NSData *data)&#123;</span><br><span class="line"></span><br><span class="line">             NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url);</span><br><span class="line">            _fetchedData &#x3D; data;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里出现了保留环：块要设置_fetchedData变量，就需要捕获self变量。而self（EOCClass实例）通过实例变量保留了获取器_networkFetcher，而_networkFetcher又保留了块。</p>
<p>解决方案是：在块中取得了data后，将_networkFetcher设为nil。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadData &#123;</span><br><span class="line"></span><br><span class="line">     NSURL *url &#x3D; [[NSURL alloc] initWithString:@&quot;http:&#x2F;&#x2F;www.example.com&#x2F;something.dat&quot;];</span><br><span class="line">    _networkFetcher &#x3D;[[EOCNetworkFetcher alloc] initWithURL:url];</span><br><span class="line">    [_networkFetcher startWithCompletionHandler:^(NSData *data)&#123;</span><br><span class="line"></span><br><span class="line">             NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url);</span><br><span class="line">            _fetchedData &#x3D; data;</span><br><span class="line">            _networkFetcher &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多用派发队列，少用同步锁"><a href="#多用派发队列，少用同步锁" class="headerlink" title="多用派发队列，少用同步锁"></a>多用派发队列，少用同步锁</h2><p>多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用GCD来为代码加锁的方式解决这个问题。</p>
<h3 id="使用串行同步队列来将读写操作都安排到同一个队列里"><a href="#使用串行同步队列来将读写操作都安排到同一个队列里" class="headerlink" title="使用串行同步队列来将读写操作都安排到同一个队列里"></a>使用串行同步队列来将读写操作都安排到同一个队列里</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue &#x3D; dispatch_queue_create(&quot;com.effectiveobjectivec.syncQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取字符串</span><br><span class="line">- (NSString*)someString &#123;</span><br><span class="line"></span><br><span class="line">         __block NSString *localSomeString;</span><br><span class="line">         dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">            localSomeString &#x3D; _someString;</span><br><span class="line">        &#125;);</span><br><span class="line">         return localSomeString;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置字符串</span><br><span class="line">- (void)setSomeString:(NSString*)someString &#123;</span><br><span class="line"></span><br><span class="line">     dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        _someString &#x3D; someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"><a href="#将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。" class="headerlink" title="将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"></a>将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">&#x2F;&#x2F;读取字符串</span><br><span class="line">- (NSString*)someString &#123;</span><br><span class="line"></span><br><span class="line">     __block NSString *localSomeString;</span><br><span class="line">     dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">        localSomeString &#x3D; _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">     return localSomeString;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;设置字符串</span><br><span class="line">- (void)setSomeString:(NSString*)someString &#123;</span><br><span class="line"></span><br><span class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</span><br><span class="line">        _someString &#x3D; someString;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。<br>这里的dispatch_barrier_async方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。</p>
</blockquote>
<h2 id="多用GCD，少用performSelector系列方法"><a href="#多用GCD，少用performSelector系列方法" class="headerlink" title="多用GCD，少用performSelector系列方法"></a>多用GCD，少用performSelector系列方法</h2><p>在iOS开发中，有时会使用performSelector来执行某个方法，但是performSelector系列的方法能处理的选择子很局限：</p>
<ul>
<li>它无法处理带有多个参数的选择子。</li>
<li>返回值只能是void或者对象类型。</li>
</ul>
<p>但是如果将方法放在块中，通过GCD来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给GCD来实现，而不是通过performSelector方法</p>
<h3 id="延后执行某个任务的方法："><a href="#延后执行某个任务的方法：" class="headerlink" title="延后执行某个任务的方法："></a>延后执行某个任务的方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 performSelector:withObject:afterDelay:</span><br><span class="line">[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 dispatch_after</span><br><span class="line">dispatch_time_t time &#x3D; dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">    [self doSomething];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="将任务放在主线程执行"><a href="#将任务放在主线程执行" class="headerlink" title="将任务放在主线程执行"></a>将任务放在主线程执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 performSelectorOnMainThread:withObject:waitUntilDone:</span><br><span class="line">[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 dispatch_async</span><br><span class="line">&#x2F;&#x2F; (or if waitUntilDone is YES, then dispatch_sync)</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self doSomething];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="掌握GCD及操作队列的使用时机"><a href="#掌握GCD及操作队列的使用时机" class="headerlink" title="掌握GCD及操作队列的使用时机"></a>掌握GCD及操作队列的使用时机</h2><p>除了GCD，操作队列（NSOperationQueue）也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用GCD好些，有时则是使用操作队列更加合理。</p>
<h3 id="使用NSOperation和NSOperationQueue的优点："><a href="#使用NSOperation和NSOperationQueue的优点：" class="headerlink" title="使用NSOperation和NSOperationQueue的优点："></a>使用NSOperation和NSOperationQueue的优点：</h3><ul>
<li>可以取消操作：在运行任务前，可以在NSOperation对象调用cancel方法，标明此任务不需要执行。但是GCD队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>
<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>
<li>监控NSOperation对象的属性：可以通过KVO来监听NSOperation的属性：可以通过isCancelled属性来判断任务是否已取消；通过isFinished属性来判断任务是否已经完成。</li>
<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。</li>
</ul>
<h2 id="通过Dispath-Group机制，根据系统资源状况来执行任务"><a href="#通过Dispath-Group机制，根据系统资源状况来执行任务" class="headerlink" title="通过Dispath Group机制，根据系统资源状况来执行任务"></a>通过Dispath Group机制，根据系统资源状况来执行任务</h2><p>有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用dispath group函数来实现这个需求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个优先级低的并发队列</span><br><span class="line">dispatch_queue_t lowPriorityQueue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个优先级高的并发队列</span><br><span class="line">dispatch_queue_t highPriorityQueue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建dispatch_group</span><br><span class="line">dispatch_group_t dispatchGroup &#x3D; dispatch_group_create();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将优先级低的队列放入dispatch_group</span><br><span class="line">for (id object in lowPriorityObjects) &#123;</span><br><span class="line"> dispatch_group_async(dispatchGroup,lowPriorityQueue,^&#123; [object performTask]; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将优先级高的队列放入dispatch_group</span><br><span class="line">for (id object in highPriorityObjects) &#123;</span><br><span class="line"> dispatch_group_async(dispatchGroup,highPriorityQueue,^&#123; [object performTask]; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dispatch_group里的任务都结束后调用块中的代码</span><br><span class="line">dispatch_queue_t notifyQueue &#x3D; dispatch_get_main_queue();</span><br><span class="line">dispatch_group_notify(dispatchGroup,notifyQueue,^&#123;</span><br><span class="line">     &#x2F;&#x2F; Continue processing after completing tasks</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="使用dispatch_once来执行只需运行一次的线程安全代码"></a>使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>有时我们可能只需要将某段代码执行一次，这时可以通过dispatch_once函数来解决。</p>
<p>dispatch_once函数比较重要的使用例子是单例模式：<br>我们在创建单例模式的实例时，可以使用dispatch_once函数来令初始化代码只执行一次，并且内部是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (id)sharedInstance &#123;</span><br><span class="line"></span><br><span class="line">     static EOCClass *sharedInstance &#x3D; nil;</span><br><span class="line">     static dispatch_once_t onceToken;</span><br><span class="line">     dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">            sharedInstance &#x3D; [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">     return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对自定义其内存管理语义的collection使用无缝桥接"><a href="#对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="对自定义其内存管理语义的collection使用无缝桥接"></a>对自定义其内存管理语义的collection使用无缝桥接</h2><p>通过无缝桥接技术，可以再Foundation框架中的OC对象和CoreFoundation框架中的C语言数据结构之间来回转换</p>

        
      
      
    </div>
    <!-- <footer class="article-footer">
      <a data-url="http://example.com/2016/07/27/EffectiveObjective-C/" data-id="cko9jcuv3000w6mqx6tc28hvi" class="article-share-link">
        分享
      </a>
      
    </footer> -->

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2018/07/15/iOS%E6%8F%90%E5%8D%87%E7%82%B9/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      iOS提升点
      
    </div>
  </a>
  
  
  <a href="/2016/03/31/Hexo%E6%95%99%E7%A8%8B/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">Hexo教程</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Hank &copy; 2021</li>
      <li>邮箱:136951866@qq.com</li>
      <!-- 
        <li></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li> -->
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Hank"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>